import { promises as fs } from "fs";
import path from "upath";
import * as logger from "../shared/logger";
import templates from "../templates";

type Page = {
  name: string;
  projectId: string;
  path: string;
  url: string;
};

async function isUserManagedFile(path: string) {
  try {
    const content = await fs.readFile(path);
    return !content
      .toString()
      .startsWith("/** This file is auto-generated by Plasmic");
  } catch (error) {
    if (error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
}

let didWarnConflictingRoot = false;
let didWarnConflictingCatchAll = false;

async function syncIndexPage(
  page: Page | undefined,
  pageDir: string,
  fileExtension: string
) {
  const fileName = `index.${fileExtension}`;
  const filePath = path.join(pageDir, fileName);
  const managedByUser = await isUserManagedFile(filePath);

  // Do not modify the file if it is managed by the user.
  if (managedByUser) {
    if (page && !didWarnConflictingRoot) {
      logger.warn(
        `Top-level ${fileName} detected.\nPlasmic uses a catch-all file to register Plasmic pages. Because of this conflict, Plasmic wont register this page.`
      );
      didWarnConflictingRoot = true;
    }
    return;
  }

  if (!page) {
    try {
      await fs.unlink(filePath);
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
    return;
  }

  await fs.writeFile(
    filePath,
    templates.PlasmicPage({
      name: page.name,
      projectId: page.projectId,
    })
  );
}

async function syncCatchAllPage(
  pages: Page[],
  pageDir: string,
  fileExtension: string
) {
  if (!pages.length) {
    return;
  }
  const topLevelPages = await fs.readdir(pageDir);
  const catchAllFile = topLevelPages.find((page) => page.startsWith("["));

  // No catch-all. We'll create our own as a default.
  if (!catchAllFile) {
    const fileName = `[...plasmicLoaderPage].${fileExtension}`;
    const filePath = path.join(pageDir, fileName);
    await fs.writeFile(filePath, templates.NextPage());
    return;
  }

  // Emit a warning if the catch all does not make use of our plasmic pages.
  const catchAllContent = await fs
    .readFile(path.join(pageDir, catchAllFile))
    .then((content) => content.toString());

  const includesPagesFunction =
    catchAllContent.includes("getPageUrls") ||
    catchAllContent.includes("getUnregisteredPageUrls");
  const includesLoaderImport = catchAllContent.includes("@plasmicapp/loader");

  if (!includesPagesFunction || !includesLoaderImport) {
    if (!didWarnConflictingCatchAll) {
      logger.warn(
        `To use PlasmicPages, please add it to your top-level catch-all "${catchAllFile}".` +
          "\n\nHere's an example on how to do it in NextJS: https://github.com/plasmicapp/nextjs-starter/blob/master/pages/[...plasmicLoaderPage].js" +
          "\n\nAlternatively, you can remove this file."
      );
    }
    didWarnConflictingCatchAll = true;
    return;
  }
}

export async function generateNextPages(
  pages: Page[],
  dir: string,
  config: any
) {
  const extension = config.code.lang === "js" ? "js" : "tsx";
  const indexPage = pages.find((page) => page.url === "/");
  const otherPages = pages.filter((page) => page.url !== "/");

  await Promise.all([
    syncIndexPage(indexPage, dir, extension),
    syncCatchAllPage(otherPages, dir, extension),
  ]);
}
